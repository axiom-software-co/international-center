package testing

import (
	"os"
	"testing"
	"time"

	"github.com/axiom-software-co/international-center/src/deployer/internal/shared/validation"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestDevelopmentEnvironmentIntegration validates the complete local development environment
// This test ensures all infrastructure components are running and properly configured
func TestDevelopmentEnvironmentIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration tests in short mode")
	}

	ctx, cancel := CreateIntegrationTestContext()
	defer cancel()

	// Arrange - Create environment validator with required configuration
	config := createDevelopmentValidationConfig(t)
	validator := validation.NewEnvironmentValidator("development", config)

	// Act - Validate complete environment
	result, err := validator.ValidateEnvironment(ctx)

	// Assert - Environment must be completely valid for development to proceed
	require.NoError(t, err, "Environment validation should not fail")
	require.NotNil(t, result, "Validation result should not be nil")
	assert.True(t, result.IsValid, "Development environment must be completely valid")
	assert.Empty(t, result.Errors, "No critical errors should exist in development environment")

	// Verify all critical services are available
	assert.True(t, result.DatabaseStatus.Available, "PostgreSQL must be available")
	assert.True(t, result.RedisStatus.Available, "Redis must be available")  
	assert.True(t, result.VaultStatus.Available, "Vault must be available")
	assert.True(t, result.AzuriteStatus.Available, "Azurite blob storage must be available")

	// Verify response times are reasonable for local development
	assert.Less(t, result.DatabaseStatus.ResponseTime, 2*time.Second, "Database response time should be fast for local development")
	assert.Less(t, result.RedisStatus.ResponseTime, 1*time.Second, "Redis response time should be fast for local development")
}

// TestDevelopmentEnvironmentReadiness validates environment readiness before running other integration tests
func TestDevelopmentEnvironmentReadiness(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration tests in short mode")
	}

	ctx, cancel := CreateIntegrationTestContext()
	defer cancel()

	// Arrange
	config := createDevelopmentValidationConfig(t)
	validator := validation.NewEnvironmentValidator("development", config)

	// Act
	result, err := validator.ValidateEnvironment(ctx)

	// Assert - This test must pass for other integration tests to be meaningful
	require.NoError(t, err)
	require.True(t, result.IsValid, "Environment must be ready before running integration tests")
	
	// Verify network connectivity is working
	assert.True(t, result.NetworkConnectivity, "Network connectivity must be established")
	
	// Verify all required ports are available  
	for _, portCheck := range result.RequiredPorts {
		assert.True(t, portCheck.Available, "Required port %d for %s must be available", portCheck.Port, portCheck.Service)
	}

	// Verify all required environment variables are set and valid
	for varName, status := range result.EnvironmentVars {
		if status.Required {
			assert.True(t, status.Present, "Required environment variable %s must be set", varName)
			assert.True(t, status.Valid, "Required environment variable %s must have valid value", varName)
		}
	}
}

// TestDevelopmentInfrastructureServices validates all infrastructure services are healthy
func TestDevelopmentInfrastructureServices(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration tests in short mode")
	}

	ctx, cancel := CreateIntegrationTestContext()
	defer cancel()

	// Arrange
	config := createDevelopmentValidationConfig(t)
	validator := validation.NewEnvironmentValidator("development", config)

	// Act
	result, err := validator.ValidateEnvironment(ctx)

	// Assert
	require.NoError(t, err)
	require.True(t, result.IsValid)

	// Test PostgreSQL database connectivity and health
	t.Run("PostgreSQL Service", func(t *testing.T) {
		assert.True(t, result.DatabaseStatus.Available, "PostgreSQL must be running and accessible")
		assert.NoError(t, result.DatabaseStatus.Error, "PostgreSQL should not have connection errors")
		assert.Equal(t, "PostgreSQL", result.DatabaseStatus.Name)
		assert.NotEmpty(t, result.DatabaseStatus.URL, "Database URL should be configured")
	})

	// Test Redis connectivity and health
	t.Run("Redis Service", func(t *testing.T) {
		assert.True(t, result.RedisStatus.Available, "Redis must be running and accessible")
		assert.NoError(t, result.RedisStatus.Error, "Redis should not have connection errors")
		assert.Equal(t, "Redis", result.RedisStatus.Name)
		assert.NotEmpty(t, result.RedisStatus.URL, "Redis URL should be configured")
	})

	// Test Vault service connectivity and health
	t.Run("Vault Service", func(t *testing.T) {
		assert.True(t, result.VaultStatus.Available, "Vault must be running and accessible")
		assert.NoError(t, result.VaultStatus.Error, "Vault should not have connection errors")
		assert.Equal(t, "Vault", result.VaultStatus.Name)
		assert.NotEmpty(t, result.VaultStatus.URL, "Vault URL should be configured")
	})

	// Test Azurite blob storage connectivity
	t.Run("Azurite Storage Service", func(t *testing.T) {
		assert.True(t, result.AzuriteStatus.Available, "Azurite must be running and accessible")
		assert.NoError(t, result.AzuriteStatus.Error, "Azurite should not have connection errors")
		assert.Equal(t, "Azurite", result.AzuriteStatus.Name)
		assert.NotEmpty(t, result.AzuriteStatus.URL, "Azurite URL should be configured")
	})

	// Test Grafana observability service (warning only - not critical for development)
	t.Run("Grafana Service", func(t *testing.T) {
		if result.GrafanaStatus.Available {
			assert.Equal(t, "Grafana", result.GrafanaStatus.Name)
			assert.NotEmpty(t, result.GrafanaStatus.URL, "Grafana URL should be configured")
		} else {
			t.Logf("Grafana is not available (non-critical for development): %v", result.GrafanaStatus.Error)
		}
	})

	// Test Loki logging service (warning only - not critical for development)  
	t.Run("Loki Service", func(t *testing.T) {
		if result.LokiStatus.Available {
			assert.Equal(t, "Loki", result.LokiStatus.Name)
			assert.NotEmpty(t, result.LokiStatus.URL, "Loki URL should be configured")
		} else {
			t.Logf("Loki is not available (non-critical for development): %v", result.LokiStatus.Error)
		}
	})
}

// createDevelopmentValidationConfig creates validation configuration for development environment
func createDevelopmentValidationConfig(t *testing.T) *validation.ValidationConfig {
	return &validation.ValidationConfig{
		DatabaseURL: getRequiredEnvVar(t, "DATABASE_URL"),
		RedisURL:    getRequiredEnvVar(t, "REDIS_URL"), 
		VaultURL:    getRequiredEnvVar(t, "VAULT_URL"),
		AzuriteURL:  getRequiredEnvVar(t, "AZURITE_URL"),
		GrafanaURL:  getEnvVar("GRAFANA_URL"),
		LokiURL:     getEnvVar("LOKI_URL"),
		Timeouts: map[string]time.Duration{
			"database": 5 * time.Second,
			"redis":    3 * time.Second,
			"vault":    5 * time.Second,
			"azurite":  3 * time.Second,
			"grafana":  5 * time.Second,
			"loki":     5 * time.Second,
			"port":     2 * time.Second,
			"network":  3 * time.Second,
			"health":   3 * time.Second,
		},
		RequiredEnvVars: []string{
			"DATABASE_URL",
			"REDIS_URL", 
			"VAULT_URL",
			"AZURITE_URL",
			"DATABASE_HOST",
			"DATABASE_PORT",
			"REDIS_HOST",
			"REDIS_PORT",
			"VAULT_HOST",
			"VAULT_PORT",
			"AZURITE_HOST",
			"AZURITE_PORT",
			"SERVICE_HOST",
		},
	}
}

// Test helper functions

// getRequiredEnvVar gets environment variable and fails test if not present
func getRequiredEnvVar(t *testing.T, key string) string {
	value := os.Getenv(key)
	require.NotEmpty(t, value, "Required environment variable %s must be set for integration tests", key)
	return value
}

// getEnvVar gets environment variable or returns empty string
func getEnvVar(key string) string {
	return os.Getenv(key)
}